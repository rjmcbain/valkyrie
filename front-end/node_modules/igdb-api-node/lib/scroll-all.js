'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var promiseWhile = function promiseWhile(condition, execute) {
    return new _promise2.default(function (resolve, reject) {
        var iterate = function iterate() {
            if (condition()) {
                return execute().then(iterate).catch(reject);
            }
            return resolve();
        };

        return iterate();
    });
};

exports.default = function (url, options, apiService, request) {
    return new _promise2.default(function (accept, reject) {
        if (!url) {
            reject(new Error('No url provided for scrollAll'));
        }

        options = (0, _assign2.default)({}, {
            interval: 200
        }, options);

        var results = [],
            xNextPage = void 0,
            xCount = void 0,
            maxPages = 2,
            currentPage = 1,
            first = true;

        promiseWhile(function () {
            if (!first) {
                if (results.length >= xCount) {
                    return false;
                }

                if (maxPages <= currentPage) {
                    return false;
                }

                currentPage += 1;
            }
            return true;
        }, function () {
            return new _promise2.default(function (accept2, reject2) {
                request('' + apiService.url + (xNextPage || url), apiService).then(function (response) {
                    if (first) {
                        first = false;
                        xNextPage = response.headers['x-next-page'];
                        xCount = parseInt(response.headers['x-count'], 10);
                        maxPages = Math.round(xCount / response.body.length);
                        if (options.pageLimit && options.pageLimit < maxPages) {
                            maxPages = options.pageLimit;
                        }
                    }

                    if (response.body && !response.body.length) {
                        return accept2();
                    }
                    results = results.concat(response.body);
                    setTimeout(function () {
                        return accept2();
                    }, options.interval);
                }).catch(reject2);
            });
        }).then(function () {
            accept(results);
        }).catch(reject);
    });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2pzL3Njcm9sbC1hbGwuanMiXSwibmFtZXMiOlsicHJvbWlzZVdoaWxlIiwiY29uZGl0aW9uIiwiZXhlY3V0ZSIsInJlc29sdmUiLCJyZWplY3QiLCJpdGVyYXRlIiwidGhlbiIsImNhdGNoIiwidXJsIiwib3B0aW9ucyIsImFwaVNlcnZpY2UiLCJyZXF1ZXN0IiwiYWNjZXB0IiwiRXJyb3IiLCJpbnRlcnZhbCIsInJlc3VsdHMiLCJ4TmV4dFBhZ2UiLCJ4Q291bnQiLCJtYXhQYWdlcyIsImN1cnJlbnRQYWdlIiwiZmlyc3QiLCJsZW5ndGgiLCJhY2NlcHQyIiwicmVqZWN0MiIsInJlc3BvbnNlIiwiaGVhZGVycyIsInBhcnNlSW50IiwiTWF0aCIsInJvdW5kIiwiYm9keSIsInBhZ2VMaW1pdCIsImNvbmNhdCIsInNldFRpbWVvdXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFNQSxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsU0FBRCxFQUFZQyxPQUFaO0FBQUEsV0FBd0Isc0JBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQzFFLFlBQU1DLFVBQVUsU0FBVkEsT0FBVSxHQUFNO0FBQ2xCLGdCQUFJSixXQUFKLEVBQWlCO0FBQ2IsdUJBQU9DLFVBQ0ZJLElBREUsQ0FDR0QsT0FESCxFQUVGRSxLQUZFLENBRUlILE1BRkosQ0FBUDtBQUdIO0FBQ0QsbUJBQU9ELFNBQVA7QUFDSCxTQVBEOztBQVNBLGVBQU9FLFNBQVA7QUFDSCxLQVg0QyxDQUF4QjtBQUFBLENBQXJCOztrQkFxQmUsVUFBQ0csR0FBRCxFQUFNQyxPQUFOLEVBQWVDLFVBQWYsRUFBMkJDLE9BQTNCO0FBQUEsV0FBdUMsc0JBQVksVUFBQ0MsTUFBRCxFQUFTUixNQUFULEVBQW9CO0FBQ2xGLFlBQUksQ0FBQ0ksR0FBTCxFQUFVO0FBQ05KLG1CQUFPLElBQUlTLEtBQUosQ0FBVSwrQkFBVixDQUFQO0FBQ0g7O0FBRURKLGtCQUFVLHNCQUFjLEVBQWQsRUFBa0I7QUFDeEJLLHNCQUFVO0FBRGMsU0FBbEIsRUFFUEwsT0FGTyxDQUFWOztBQUlBLFlBQUlNLFVBQVUsRUFBZDtBQUFBLFlBQ0lDLGtCQURKO0FBQUEsWUFFSUMsZUFGSjtBQUFBLFlBR0lDLFdBQVcsQ0FIZjtBQUFBLFlBSUlDLGNBQWMsQ0FKbEI7QUFBQSxZQUtJQyxRQUFRLElBTFo7O0FBT0FwQixxQkFDSSxZQUFNO0FBQ0YsZ0JBQUksQ0FBQ29CLEtBQUwsRUFBWTtBQUVSLG9CQUFJTCxRQUFRTSxNQUFSLElBQWtCSixNQUF0QixFQUE4QjtBQUMxQiwyQkFBTyxLQUFQO0FBQ0g7O0FBR0Qsb0JBQUlDLFlBQVlDLFdBQWhCLEVBQTZCO0FBQ3pCLDJCQUFPLEtBQVA7QUFDSDs7QUFFREEsK0JBQWUsQ0FBZjtBQUNIO0FBQ0QsbUJBQU8sSUFBUDtBQUNILFNBaEJMLEVBaUJJO0FBQUEsbUJBQU0sc0JBQVksVUFBQ0csT0FBRCxFQUFVQyxPQUFWLEVBQXNCO0FBQ3BDWiw2QkFBV0QsV0FBV0YsR0FBdEIsSUFBNEJRLGFBQWFSLEdBQXpDLEdBQWdERSxVQUFoRCxFQUNLSixJQURMLENBQ1Usb0JBQVk7QUFDZCx3QkFBSWMsS0FBSixFQUFXO0FBQ1BBLGdDQUFRLEtBQVI7QUFDQUosb0NBQVlRLFNBQVNDLE9BQVQsQ0FBaUIsYUFBakIsQ0FBWjtBQUNBUixpQ0FBU1MsU0FBU0YsU0FBU0MsT0FBVCxDQUFpQixTQUFqQixDQUFULEVBQXNDLEVBQXRDLENBQVQ7QUFDQVAsbUNBQVdTLEtBQUtDLEtBQUwsQ0FBV1gsU0FBU08sU0FBU0ssSUFBVCxDQUFjUixNQUFsQyxDQUFYO0FBR0EsNEJBQUlaLFFBQVFxQixTQUFSLElBQXFCckIsUUFBUXFCLFNBQVIsR0FBb0JaLFFBQTdDLEVBQXVEO0FBQ25EQSx1Q0FBV1QsUUFBUXFCLFNBQW5CO0FBQ0g7QUFDSjs7QUFHRCx3QkFBSU4sU0FBU0ssSUFBVCxJQUFpQixDQUFDTCxTQUFTSyxJQUFULENBQWNSLE1BQXBDLEVBQTRDO0FBQ3hDLCtCQUFPQyxTQUFQO0FBQ0g7QUFDRFAsOEJBQVVBLFFBQVFnQixNQUFSLENBQWVQLFNBQVNLLElBQXhCLENBQVY7QUFDQUcsK0JBQVc7QUFBQSwrQkFBTVYsU0FBTjtBQUFBLHFCQUFYLEVBQTRCYixRQUFRSyxRQUFwQztBQUNILGlCQXBCTCxFQW9CT1AsS0FwQlAsQ0FvQmFnQixPQXBCYjtBQXFCSCxhQXRCSyxDQUFOO0FBQUEsU0FqQkosRUF3Q0VqQixJQXhDRixDQXdDTyxZQUFNO0FBQ1RNLG1CQUFPRyxPQUFQO0FBQ0gsU0ExQ0QsRUEwQ0dSLEtBMUNILENBMENTSCxNQTFDVDtBQTJDSCxLQTNEcUQsQ0FBdkM7QUFBQSxDIiwiZmlsZSI6InNjcm9sbC1hbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcm9taXNlV2hpbGUgPSAoY29uZGl0aW9uLCBleGVjdXRlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaXRlcmF0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oaXRlcmF0ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaXRlcmF0ZSgpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBwYWdlcyBvciBhIGxpbWl0ZWQgc2V0IGFuZCByZXR1cm5zIGEgc2luZ2xlIGNvbmNhdGluYXRlZCBvYmplY3QuXG4gKiBAYXJnIHtTdHJpbmd9IHVybCBBIHF1ZXJ5IHVybFxuICogQGFyZyB7T2JqZWN0fSBvcHRpb25zIGEgc2VsZWN0aW9uIG9mIG9wdGlvbnMuXG4gKiBAYXJnIHtPYmplY3R9IGFwaVNlcnZpY2UgVGhlIEFQSSBzZXJ2aWNlIG9iamVjdCBjb250YWluaW5nIGVuZHBvaW50IGRldGFpbHMgYW5kIGtleVxuICogQGFyZyB7RnVuY3Rpb259IHJlcXVlc3QgVGhlIHBlcmZvcm0tcmVxdWVzdCBmdW5jdGlvblxuICogQHJldHVybnMge09iamVjdH0gQ29uY2F0aW5hdGVkIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKHVybCwgb3B0aW9ucywgYXBpU2VydmljZSwgcmVxdWVzdCkgPT4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdXJsIHByb3ZpZGVkIGZvciBzY3JvbGxBbGwnKSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgaW50ZXJ2YWw6IDIwMFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXSxcbiAgICAgICAgeE5leHRQYWdlLFxuICAgICAgICB4Q291bnQsXG4gICAgICAgIG1heFBhZ2VzID0gMixcbiAgICAgICAgY3VycmVudFBhZ2UgPSAxLFxuICAgICAgICBmaXJzdCA9IHRydWU7XG5cbiAgICBwcm9taXNlV2hpbGUoXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBwYWdlIG9mIHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IHhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYWxsIHBhZ2VzIGhhdmUgYmVlbiByZXRyaWV2ZWRcbiAgICAgICAgICAgICAgICBpZiAobWF4UGFnZXMgPD0gY3VycmVudFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gbmV3IFByb21pc2UoKGFjY2VwdDIsIHJlamVjdDIpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QoYCR7YXBpU2VydmljZS51cmx9JHt4TmV4dFBhZ2UgfHwgdXJsfWAsIGFwaVNlcnZpY2UpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB4TmV4dFBhZ2UgPSByZXNwb25zZS5oZWFkZXJzWyd4LW5leHQtcGFnZSddOyAvLyBOb3cgb25seSBxdWVyeSB0aGUgY3Vyc29yIHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhDb3VudCA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnNbJ3gtY291bnQnXSwgMTApOyAvLyBTZXQgdGhlIHRvdGFsIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFBhZ2VzID0gTWF0aC5yb3VuZCh4Q291bnQgLyByZXNwb25zZS5ib2R5Lmxlbmd0aCk7IC8vIENvbnZlcnQgdG90YWwgcmVzdWx0cyB0byB0b3RhbCBwYWdlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyBvbmx5IGEgbGltaXRlZCBudW1iZXIgb2YgcGFnZXMsIG92ZXJyaWRlIHRoZSBtYXggcGFnZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlTGltaXQgJiYgb3B0aW9ucy5wYWdlTGltaXQgPCBtYXhQYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBhZ2VzID0gb3B0aW9ucy5wYWdlTGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHBhZ2Ugb2YgcmVzdWx0cyBvciBzb21lIG90aGVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5ib2R5ICYmICFyZXNwb25zZS5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VwdDIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0MigpLCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QyKTtcbiAgICAgICAgfSksXG4gICAgKS50aGVuKCgpID0+IHtcbiAgICAgICAgYWNjZXB0KHJlc3VsdHMpO1xuICAgIH0pLmNhdGNoKHJlamVjdCk7XG59KTtcbiJdfQ==